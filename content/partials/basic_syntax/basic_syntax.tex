\section{Basic Syntax}

  \subsection{If/Else \& For In}
    \mypy{content/partials/basic_syntax/if_else_for_in.py}
    \mytext{content/partials/basic_syntax/if_else_for_in.out}

  \subsection{Ternary Operator (Inline If/Else)}
    The ternary operators works like in other languages, however, you're not using special
    characters like \textit{?} or \textit{:} but the keywords \textit{if} and \textit{else}
    
    \mypy{content/partials/basic_syntax/inline_if.py}
    \mytext{content/partials/basic_syntax/inline_if.out}
    Note that, however, \mintinline{python}{x = 1 if some_condition} is not valid; you need an
    \mintinline{python}{else} statement.

  \subsection{Chaining Conditions}
    Python enables you to chain conditions:
    
    \mypy{content/partials/basic_syntax/chaining_conditions.py}
    \mytext{content/partials/basic_syntax/chaining_conditions.out}

  \subsection{Strings And Comments}
    Single line comments start with a \#, docstrings ('multiline comments') comments start and end with """. \\
    However, you should use \# for 'normal' comments and """ for docstrings (e.g. explaining the purpose of a class or function).
    
    You can also use """ to create multiline strings:
    
    \mypy{content/partials/basic_syntax/comments_multiline_strings.py}
    \mytext{content/partials/basic_syntax/comments_multiline_strings.out}
  
    \subsubsection{String Formatting}
      Concatenating strings with numbers (e.g. \mintinline{python}{"Python" + 101}) results in an error. \\
      Gladly, there are some workarounds on how to format your strings:
    
      \begin{enumerate}
        \item Making everything a string: \mintinline{python}{"Python" + str(101)}
        \item Modulo Operator: \mintinline{python}{"Python %s" % (101)} \\
          Calculating string module tuple works because Python enables you to overwrite operators. This has nothing to do with an actual modulo operation, it's just an easy-to-use syntax.
        \item Format Method: \mintinline{python}{"Python {}".format(101)}
        \item F-Strings: \mintinline{python}{f"Python {101}"}
      \end{enumerate}
        
      Here are some examples:
      
      \mypy{content/partials/basic_syntax/string_formatting_examples.py}
      \mytext{content/partials/basic_syntax/string_formatting_examples.out}

  \subsection{'Main' In Python}
    You probably know the \textit{main()} method from other languages such as Java or C. \\
    Python, on the other hand, is primarily used for scripting, meaning there's a specific file
    to be run rather than a single executable program. \\
    By default, a Python file is executed from top to bottom, no matter whether this is the
    'main' file (the file started e.g. from the command line by using
    \mintinline{bash}{python main.py}) or just a module imported by \textit{main.py}.

    If you want some part of a program only executed if it's the 'main' file, so the 'entry point'
    to your program, you can check whether a certain variable called \mintinline{Python}{__name__}
    is equal to \mintinline{Python}{"__main__"}:

    \mypy{content/partials/basic_syntax/main_example.py}
    \mytext{content/partials/basic_syntax/main_example.out}

    If you import this file from another file and execute the latter one, the code within the main
    of the imported file will not be executed.
      
  
  \subsection{Exception Handling}
    You probably already know Error or Exception Handling from other object-oriented
    programming languages.
    
    This is what its syntax looks like in Python:
    \mypy{content/partials/basic_syntax/exception_handling.py}
    \mytext{content/partials/basic_syntax/exception_handling.out}

    If you want to raise (in other languages 'throw') an error, use the raise keyword:
    \mypy{content/partials/basic_syntax/raise_exception.py}
    \mytext{content/partials/basic_syntax/raise_exception.out}

